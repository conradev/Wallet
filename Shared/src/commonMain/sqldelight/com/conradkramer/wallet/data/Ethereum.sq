CREATE TABLE eth_block (
    chain_id INTEGER AS com.conradkramer.wallet.ethereum.types.Chain NOT NULL,
    number INTEGER NOT NULL,
    timestamp TEXT AS kotlinx.datetime.Instant NOT NULL,

    PRIMARY KEY (chain_id, number)
);

CREATE TABLE eth_transaction (
    block INTEGER NOT NULL,
    chain_id INTEGER AS com.conradkramer.wallet.ethereum.types.Chain NOT NULL,
    tx_index INTEGER NOT NULL,
    hash BLOB AS com.conradkramer.wallet.ethereum.types.Data UNIQUE NOT NULL,
    [from] BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    [to] BLOB AS com.conradkramer.wallet.ethereum.types.Address,
    value BLOB AS com.conradkramer.wallet.ethereum.types.Quantity NOT NULL,

    PRIMARY KEY (chain_id, block, tx_index),
    FOREIGN KEY (chain_id, block) REFERENCES eth_block(chain_id, number) ON DELETE CASCADE
);

CREATE TABLE eth_token_transfer (
    chain_id INTEGER AS com.conradkramer.wallet.ethereum.types.Chain NOT NULL,
    block INTEGER NOT NULL,
    tx_index INTEGER NOT NULL,
    log_index INTEGER NOT NULL,
    contract BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    [from] BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    [to] BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    value BLOB AS com.conradkramer.wallet.ethereum.types.Quantity,

    PRIMARY KEY (chain_id, block, tx_index, log_index)
);

CREATE TABLE erc20_contract (
    chain_id INTEGER AS com.conradkramer.wallet.ethereum.types.Chain NOT NULL,
    address BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    total_supply BLOB AS com.conradkramer.wallet.ethereum.types.Quantity NOT NULL,
    symbol TEXT,
    decimals INTEGER,
    name TEXT,

    PRIMARY KEY (chain_id, address)
);

CREATE TABLE erc721_contract (
    chain_id INTEGER AS com.conradkramer.wallet.ethereum.types.Chain NOT NULL,
    address BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    symbol TEXT,
    name TEXT,
    total_supply BLOB AS com.conradkramer.wallet.ethereum.types.Quantity,

    PRIMARY KEY (chain_id, address)
);

CREATE TABLE erc721_token (
    chain_id INTEGER AS com.conradkramer.wallet.ethereum.types.Chain NOT NULL,
    contract BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    id BLOB AS com.conradkramer.wallet.ethereum.types.Quantity NOT NULL,
    owner BLOB AS com.conradkramer.wallet.ethereum.types.Address,
    name TEXT,
    description TEXT,
    image TEXT,
    external_uri TEXT,
    attributes TEXT,
    token_uri TEXT,

    PRIMARY KEY (contract, id),
    FOREIGN KEY (chain_id, contract) REFERENCES erc721_contract(chain_id, address) ON DELETE CASCADE
);

CREATE TABLE erc20_balance (
    chain_id INTEGER AS com.conradkramer.wallet.ethereum.types.Chain NOT NULL,
    contract BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    address BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    balance BLOB AS com.conradkramer.wallet.ethereum.types.Quantity NOT NULL,
    block INTEGER NOT NULL,

    PRIMARY KEY (chain_id, address, contract),
    FOREIGN KEY (chain_id, contract) REFERENCES erc20_contract(chain_id, address) ON DELETE CASCADE
);

CREATE TABLE ens_lookup (
    chain_id INTEGER AS com.conradkramer.wallet.ethereum.types.Chain NOT NULL,
    name TEXT NOT NULL,
    address BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    block INTEGER NOT NULL,
    avatar TEXT,
    description TEXT,
    display TEXT,
    email TEXT,
    notice TEXT,
    location TEXT,
    phone TEXT,
    url TEXT,

    PRIMARY KEY (chain_id, name)
);

CREATE TABLE ens_reverse_lookup (
    chain_id INTEGER AS com.conradkramer.wallet.ethereum.types.Chain NOT NULL,
    address BLOB AS com.conradkramer.wallet.ethereum.types.Address NOT NULL,
    name TEXT NOT NULL,
    block INTEGER NOT NULL,

    PRIMARY KEY (chain_id, address)
);

blocks:
SELECT count(*) FROM eth_block;

blockTime:
SELECT timestamp FROM eth_block WHERE number = ?;

insertBlock:
INSERT INTO eth_block(chain_id, number, timestamp)
VALUES ?
ON CONFLICT(chain_id, number) DO NOTHING;

insertTransaction:
INSERT INTO eth_transaction(chain_id, block, tx_index, hash, [from], [to], value)
VALUES ?
ON CONFLICT (chain_id, block, tx_index) DO NOTHING;

insertTokenTransfer:
INSERT INTO eth_token_transfer(chain_id, block, tx_index, log_index, contract, [from], [to], value)
VALUES ?
ON CONFLICT (chain_id, block, tx_index, log_index) DO NOTHING;

insertTokenContract:
INSERT INTO erc20_contract(chain_id, address, total_supply, symbol, decimals, name)
VALUES ?
ON CONFLICT (chain_id, address)
DO UPDATE SET total_supply = excluded.total_supply, symbol = excluded.symbol, decimals = excluded.decimals, name = excluded.name;

insertNonfungibleTokenContract:
INSERT INTO erc721_contract(chain_id, address, symbol, name, total_supply)
VALUES ?
ON CONFLICT (chain_id, address)
DO UPDATE SET symbol = excluded.symbol, name = excluded.name, total_supply = excluded.total_supply;

tokenContractsToIndex:
SELECT contract FROM eth_token_transfer AS transfer
LEFT JOIN erc20_contract AS erc20 ON erc20.chain_id == transfer.chain_id AND erc20.address == transfer.contract
LEFT JOIN erc721_contract AS erc721 ON erc721.chain_id == transfer.chain_id AND erc721.address == transfer.contract
WHERE transfer.chain_id = ? AND erc20.chain_id IS NULL AND erc721.chain_id IS NULL;

nonfungibleTokensToIndex:
SELECT transfer.contract, transfer.value FROM eth_token_transfer AS transfer
LEFT JOIN erc721_contract ON erc721_contract.chain_id == transfer.chain_id AND erc721_contract.address == transfer.contract
LEFT JOIN erc721_token AS token ON token.chain_id == transfer.chain_id AND token.contract == transfer.contract AND id == transfer.value
WHERE transfer.chain_id = ? AND transfer.value IS NOT NULL AND erc721_contract.chain_id IS NOT NULL AND token.chain_id IS NULL;
